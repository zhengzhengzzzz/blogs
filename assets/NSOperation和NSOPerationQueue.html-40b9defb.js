import{_ as a,o as s,c as e,e as n}from"./app-6d1bfb61.js";const l={},o=n(`<blockquote><h1 id="一-nsoperatioin" tabindex="-1"><a class="header-anchor" href="#一-nsoperatioin" aria-hidden="true">#</a> 一. NSOperatioin</h1></blockquote><h4 id="_1-目的" tabindex="-1"><a class="header-anchor" href="#_1-目的" aria-hidden="true">#</a> 1.目的</h4><ul><li>开启线程</li><li>提供一些 GCD 不具备的功能</li><li>OC 框架,内部封装的是 GCD</li></ul><h4 id="_2-区别" tabindex="-1"><a class="header-anchor" href="#_2-区别" aria-hidden="true">#</a> 2.区别</h4><ul><li>GCD 执行效率高于 NSOperation</li><li>NSOperation 提供了一些 GCD 中不具备的功能(暂停/恢复/取消)---管理操作-NSOperation 的高级用法</li></ul><h4 id="_3-nsoperation-本身是一个抽象类不可以直接使用-实际开发中使用其子类" tabindex="-1"><a class="header-anchor" href="#_3-nsoperation-本身是一个抽象类不可以直接使用-实际开发中使用其子类" aria-hidden="true">#</a> 3.NSOperation 本身是一个抽象类不可以直接使用,实际开发中使用其子类</h4><ul><li><p>苹果提供了两个原生子类</p><ul><li>NSInvocationOperation<div class="language-objc line-numbers-mode" data-ext="objc"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">NSInvocationOperation</span><span style="color:#ABB2BF;"> *op </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> [[</span><span style="color:#E5C07B;">NSInvocationOperation</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">alloc</span><span style="color:#ABB2BF;">]  initWithTarget:</span><span style="color:#E5C07B;">self</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">selector:</span><span style="color:#C678DD;">@selector(</span><span style="color:#61AFEF;">test</span><span style="color:#C678DD;">)</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">object:</span><span style="color:#D19A66;">nil</span><span style="color:#ABB2BF;">];</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li>NSBlockOperation 将操作封装在 block 中<div class="language-objc line-numbers-mode" data-ext="objc"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;"> NSBlockOperation *op1 </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> [NSBlockOperation </span><span style="color:#61AFEF;">blockOperationWithBlock:</span><span style="color:#ABB2BF;">^{</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 可以追加操作(无限)---如果在非主队列执行操作,原操作和追加的操作都会 开启多条线程去执行</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#56B6C2;">NSLog</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">@&quot;操作 1---------</span><span style="color:#D19A66;">%@</span><span style="color:#98C379;">&quot;</span><span style="color:#ABB2BF;">,[</span><span style="color:#E5C07B;">NSThread</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">currentThread</span><span style="color:#ABB2BF;">]);</span></span>
<span class="line"><span style="color:#ABB2BF;">}];</span></span>
<span class="line"><span style="color:#ABB2BF;">[op1 </span><span style="color:#61AFEF;">addExecutionBlock:</span><span style="color:#ABB2BF;">^{</span></span>
<span class="line"><span style="color:#ABB2BF;">   </span><span style="color:#56B6C2;">NSLog</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">@&quot;追加操作 2-----------</span><span style="color:#D19A66;">%@</span><span style="color:#98C379;">&quot;</span><span style="color:#ABB2BF;">,[</span><span style="color:#E5C07B;">NSThread</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">currentThread</span><span style="color:#ABB2BF;">]);</span></span>
<span class="line"><span style="color:#ABB2BF;">}];</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>缺点:</p><ul><li>有过在主队列执行操作,有一个操作在主线程执行(随机),其他操作在子线程执行 - 如果直接调用 start 方法执行操作,无法确定每一个操作在哪条线程执行</li><li>一般不要追加操作,除非就是在非主队列执行</li></ul></li><li><p>操作依赖 (串行/线程同步技术)添加数量不要太多</p><ul><li>对于不同的操作队列中的操作依然有效</li><li>添加操作依赖要在添加操作队列之前</li><li>只能对添加在操作队列的操作添加依赖</li><li>一定不要添加循环依赖</li></ul></li></ul><hr><blockquote><h1 id="一-nsoperatioinqueue" tabindex="-1"><a class="header-anchor" href="#一-nsoperatioinqueue" aria-hidden="true">#</a> 一. NSOperatioinQueue</h1></blockquote><h4 id="_1-主队列" tabindex="-1"><a class="header-anchor" href="#_1-主队列" aria-hidden="true">#</a> 1.主队列</h4><ul><li>放在主队列中的操作,都在主线程执行</li></ul><pre><code>NSOPerationQueue mainQueue</code></pre><h4 id="_2-非主队列" tabindex="-1"><a class="header-anchor" href="#_2-非主队列" aria-hidden="true">#</a> 2.非主队列</h4><ul><li>放在非主队列中的操作,都在子线程执行</li></ul><pre><code>[[NSOPerationQueue alloc] init]</code></pre><h4 id="_3-一般定义成全局属性" tabindex="-1"><a class="header-anchor" href="#_3-一般定义成全局属性" aria-hidden="true">#</a> 3.一般定义成全局属性</h4><hr><h4 id="_4-每一个操作都有一个-start-方法-用来在当前线程执行" tabindex="-1"><a class="header-anchor" href="#_4-每一个操作都有一个-start-方法-用来在当前线程执行" aria-hidden="true">#</a> 4.每一个操作都有一个 start 方法,用来在当前线程执行</h4><ul><li><p>本质:将操作添加到操作队列之后,内部会自动调用内部 start 方法,操作就会自动执行</p></li><li><p>主队列和非主队列决定操作在哪条线程执行(在哪条线程启动操作的 start 方法)</p></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#abb2bf;"></span></span></code></pre><div class="line-numbers" aria-hidden="true"></div></div>`,20),i=[o];function r(p,t){return s(),e("div",null,i)}const d=a(l,[["render",r],["__file","NSOperation和NSOPerationQueue.html.vue"]]);export{d as default};

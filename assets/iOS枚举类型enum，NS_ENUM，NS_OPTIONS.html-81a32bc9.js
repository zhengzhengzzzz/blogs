const e=JSON.parse('{"key":"v-a6d779e2","path":"/posts/iOS/system/iOS%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benum%EF%BC%8CNS_ENUM%EF%BC%8CNS_OPTIONS.html","title":"OC 中的枚举类型","lang":"zh-CN","frontmatter":{"title":"OC 中的枚举类型","date":"2017-01-06T11:19:16.000Z","category":["iOS"],"tag":["iOS","Objectiv-C语法"],"description":"进入正题，今天介绍一下objective-c中的枚举 提要 首先要知道的是,枚举值 它是一个整形(int) 并且,它不参加内存的占用和释放 枚举定义变量即可直接使用,不用初始化 三种类型的枚举 enum 在iOS6之前一般我们采用C风格的enum关键字可以定义枚举类型 在iOS6之后引入两个宏来定义枚举实际上是将enum定义和typedef合二为一，并且采用不同的宏来从代码角度来区分。 NS_ENUM 普通枚举定义可参见UIKit.Framework中 NS_OPTIONS 位运算及特殊枚举的定义。什么时候要用到这种方式呢? 那就是一个枚举变量可能要代表多个枚举值的时候. 其实给一个枚举变量赋予多个枚举值的时候,原理只是把各个枚举值加起来罢了. 当加起来以后,就获取了一个新的值,那么为了保证这个值的唯一性,这个时候就体现了位运算的重要作用. 位运算可以确保枚举值组合的唯一性. 因为位运算的计算方式是将二进制转换成十进制,也就是说,枚举值里面存取的是 计算后的十进制值. 打个比方: 通过上面的位运算方式设定好枚举以后,打印出来的枚举值分别是: 1 2 4 8 16 这5个数字,无论你如何组合在一起,也不会产生两个同样的数字. 这两个宏的定义在Foundation.framework的NSObjCRuntime.h中：","head":[["meta",{"property":"og:url","content":"https://oragekk.me/blogs/posts/iOS/system/iOS%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benum%EF%BC%8CNS_ENUM%EF%BC%8CNS_OPTIONS.html"}],["meta",{"property":"og:site_name","content":"茜茜的博客"}],["meta",{"property":"og:title","content":"OC 中的枚举类型"}],["meta",{"property":"og:description","content":"进入正题，今天介绍一下objective-c中的枚举 提要 首先要知道的是,枚举值 它是一个整形(int) 并且,它不参加内存的占用和释放 枚举定义变量即可直接使用,不用初始化 三种类型的枚举 enum 在iOS6之前一般我们采用C风格的enum关键字可以定义枚举类型 在iOS6之后引入两个宏来定义枚举实际上是将enum定义和typedef合二为一，并且采用不同的宏来从代码角度来区分。 NS_ENUM 普通枚举定义可参见UIKit.Framework中 NS_OPTIONS 位运算及特殊枚举的定义。什么时候要用到这种方式呢? 那就是一个枚举变量可能要代表多个枚举值的时候. 其实给一个枚举变量赋予多个枚举值的时候,原理只是把各个枚举值加起来罢了. 当加起来以后,就获取了一个新的值,那么为了保证这个值的唯一性,这个时候就体现了位运算的重要作用. 位运算可以确保枚举值组合的唯一性. 因为位运算的计算方式是将二进制转换成十进制,也就是说,枚举值里面存取的是 计算后的十进制值. 打个比方: 通过上面的位运算方式设定好枚举以后,打印出来的枚举值分别是: 1 2 4 8 16 这5个数字,无论你如何组合在一起,也不会产生两个同样的数字. 这两个宏的定义在Foundation.framework的NSObjCRuntime.h中："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-24T08:54:35.000Z"}],["meta",{"property":"article:author","content":"茜茜"}],["meta",{"property":"article:tag","content":"iOS"}],["meta",{"property":"article:tag","content":"Objectiv-C语法"}],["meta",{"property":"article:published_time","content":"2017-01-06T11:19:16.000Z"}],["meta",{"property":"article:modified_time","content":"2023-07-24T08:54:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"OC 中的枚举类型\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2017-01-06T11:19:16.000Z\\",\\"dateModified\\":\\"2023-07-24T08:54:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"茜茜\\",\\"url\\":\\"https://orgaekk.me\\"}]}"]]},"headers":[{"level":3,"title":"提要","slug":"提要","link":"#提要","children":[]},{"level":3,"title":"举个🌰","slug":"举个🌰","link":"#举个🌰","children":[]}],"git":{"createdTime":1690188875000,"updatedTime":1690188875000,"contributors":[{"name":"Zzhgitup","email":"99540215+Zzhgitup@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":2.12,"words":636},"filePathRelative":"posts/iOS/system/iOS枚举类型enum，NS_ENUM，NS_OPTIONS.md","localizedDate":"2017年1月6日","excerpt":"<blockquote>\\n<p>进入正题，今天介绍一下objective-c中的枚举</p>\\n</blockquote>\\n<h3> 提要</h3>\\n<ul>\\n<li>\\n<p>首先要知道的是,枚举值 它是一个整形(int) 并且,它不参加内存的占用和释放 枚举定义变量即可直接使用,不用初始化</p>\\n</li>\\n<li>\\n<p>三种类型的枚举</p>\\n<ul>\\n<li><strong>enum</strong> 在iOS6之前一般我们采用C风格的enum关键字可以定义枚举类型</li>\\n</ul>\\n<p>在iOS6之后引入两个宏来定义枚举实际上是将enum定义和typedef合二为一，并且采用不同的宏来从代码角度来区分。</p>\\n<ul>\\n<li>\\n<p><strong>NS_ENUM</strong>  普通枚举定义可参见UIKit.Framework中</p>\\n</li>\\n<li>\\n<p><strong>NS_OPTIONS</strong>  位运算及特殊枚举的定义。什么时候要用到这种方式呢? 那就是一个枚举变量可能要代表多个枚举值的时候. 其实给一个枚举变量赋予多个枚举值的时候,原理只是把各个枚举值加起来罢了. 当加起来以后,就获取了一个新的值,那么为了保证这个值的唯一性,这个时候就体现了位运算的重要作用. 位运算可以确保枚举值组合的唯一性. 因为位运算的计算方式是将二进制转换成十进制,也就是说,枚举值里面存取的是 计算后的十进制值. 打个比方: 通过上面的位运算方式设定好枚举以后,打印出来的枚举值分别是: 1 2 4 8 16 这5个数字,无论你如何组合在一起,也不会产生两个同样的数字.</p>\\n</li>\\n</ul>\\n<p>这两个宏的定义在Foundation.framework的NSObjCRuntime.h中：</p>\\n</li>\\n</ul>","copyright":{"author":"Oragekk","license":"CC BY-NC-SA 4.0"},"autoDesc":true}');export{e as data};
